<!-- Generated by pkgdown: do not edit by hand -->
<!DOCTYPE html>
<html lang="en">
  <head>
  <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>Correlations among multiple variates with phylogenetic signal — cor_phylo • phyr</title>


<!-- jquery -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script>
<!-- Bootstrap -->

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/css/bootstrap.min.css" integrity="sha256-bZLfwXAP04zRMK2BjiO8iu9pf4FbLqX6zitd+tIvLhE=" crossorigin="anonymous" />

<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/js/bootstrap.min.js" integrity="sha256-nuL8/2cJ5NDSSwnKD8VqreErSWHtnEP9E7AySL+1ev4=" crossorigin="anonymous"></script>

<!-- bootstrap-toc -->
<link rel="stylesheet" href="../bootstrap-toc.css">
<script src="../bootstrap-toc.js"></script>

<!-- Font Awesome icons -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous" />

<!-- clipboard.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script>

<!-- headroom.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script>

<!-- pkgdown -->
<link href="../pkgdown.css" rel="stylesheet">
<script src="../pkgdown.js"></script>




<meta property="og:title" content="Correlations among multiple variates with phylogenetic signal — cor_phylo" />
<meta property="og:description" content="This function calculates Pearson correlation coefficients for multiple continuous
variates that may have phylogenetic signal, allowing users to specify measurement
error as the standard error of variate values at the tips of the phylogenetic tree.
Phylogenetic signal for each variate is estimated from the data assuming that variate
evolution is given by a Ornstein-Uhlenbeck process.  Thus, the function allows the
estimation of phylogenetic signal in multiple variates while incorporating
correlations among variates. It is also possible to include independent variables
(covariates) for each variate to remove possible confounding effects.
cor_phylo returns the correlation matrix for variate values, estimates
of phylogenetic signal for each variate, and regression coefficients for
independent variables affecting each variate." />




<!-- mathjax -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script>

<!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->



  </head>

  <body data-spy="scroll" data-target="#toc">
    <div class="container template-reference-topic">
      <header>
      <div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">phyr</a>
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="Released version">1.1.0</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="../index.html">
    <span class="fas fa fas fa-home fa-lg"></span>
     
  </a>
</li>
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Articles
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="../articles/benchmarks.html">Performance benchmark</a>
    </li>
    <li>
      <a href="../articles/pglmm.html">Usage of pglmm()</a>
    </li>
    <li>
      <a href="../articles/phyr_example_empirical.html">pglmm example with empirical data</a>
    </li>
    <li>
      <a href="../articles/plot-re.html">Plot random terms of communityPGLMM</a>
    </li>
  </ul>
</li>
<li>
  <a href="../news/index.html">Changelog</a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="https://github.com/daijiang/phyr/">
    <span class="fab fa fab fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
      
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

      

      </header>

<div class="row">
  <div class="col-md-9 contents">
    <div class="page-header">
    <h1>Correlations among multiple variates with phylogenetic signal</h1>
    <small class="dont-index">Source: <a href='https://github.com/daijiang/phyr/blob/master/R/cor_phylo.R'><code>R/cor_phylo.R</code></a></small>
    <div class="hidden name"><code>cor_phylo.Rd</code></div>
    </div>

    <div class="ref-description">
    <p>This function calculates Pearson correlation coefficients for multiple continuous
variates that may have phylogenetic signal, allowing users to specify measurement
error as the standard error of variate values at the tips of the phylogenetic tree.
Phylogenetic signal for each variate is estimated from the data assuming that variate
evolution is given by a Ornstein-Uhlenbeck process.  Thus, the function allows the
estimation of phylogenetic signal in multiple variates while incorporating
correlations among variates. It is also possible to include independent variables
(covariates) for each variate to remove possible confounding effects.
<code>cor_phylo</code> returns the correlation matrix for variate values, estimates
of phylogenetic signal for each variate, and regression coefficients for
independent variables affecting each variate.</p>
    </div>

    <pre class="usage"><span class='fu'>cor_phylo</span><span class='op'>(</span><span class='va'>variates</span>, <span class='va'>species</span>, <span class='va'>phy</span>,
          covariates <span class='op'>=</span> <span class='cn'>NULL</span>, 
          meas_errors <span class='op'>=</span> <span class='cn'>NULL</span>,
          data <span class='op'>=</span> <span class='fu'><a href='https://rdrr.io/r/base/sys.parent.html'>sys.frame</a></span><span class='op'>(</span><span class='fu'><a href='https://rdrr.io/r/base/sys.parent.html'>sys.parent</a></span><span class='op'>(</span><span class='op'>)</span><span class='op'>)</span>,
          REML <span class='op'>=</span> <span class='cn'>TRUE</span>, 
          method <span class='op'>=</span> <span class='fu'><a href='https://rdrr.io/r/base/c.html'>c</a></span><span class='op'>(</span><span class='st'>"nelder-mead-r"</span>, <span class='st'>"bobyqa"</span>,
              <span class='st'>"subplex"</span>, <span class='st'>"nelder-mead-nlopt"</span>, <span class='st'>"sann"</span><span class='op'>)</span>,
          no_corr <span class='op'>=</span> <span class='cn'>FALSE</span>,
          constrain_d <span class='op'>=</span> <span class='cn'>FALSE</span>,
          lower_d <span class='op'>=</span> <span class='fl'>1e-7</span>,
          rel_tol <span class='op'>=</span> <span class='fl'>1e-6</span>,
          max_iter <span class='op'>=</span> <span class='fl'>1000</span>,
          sann_options <span class='op'>=</span> <span class='cn'>NULL</span>,
          verbose <span class='op'>=</span> <span class='cn'>FALSE</span>,
          rcond_threshold <span class='op'>=</span> <span class='fl'>1e-10</span>,
          boot <span class='op'>=</span> <span class='fl'>0</span>,
          keep_boots <span class='op'>=</span> <span class='fu'><a href='https://rdrr.io/r/base/c.html'>c</a></span><span class='op'>(</span><span class='st'>"fail"</span>, <span class='st'>"none"</span>, <span class='st'>"all"</span><span class='op'>)</span><span class='op'>)</span>

<span class='co'># S3 method for cor_phylo</span>
<span class='fu'><a href='boot_ci.html'>boot_ci</a></span><span class='op'>(</span><span class='va'>mod</span>, refits <span class='op'>=</span> <span class='cn'>NULL</span>, alpha <span class='op'>=</span> <span class='fl'>0.05</span>, <span class='va'>...</span><span class='op'>)</span>

<span class='co'># S3 method for cor_phylo</span>
<span class='fu'><a href='https://rdrr.io/r/base/print.html'>print</a></span><span class='op'>(</span><span class='va'>x</span>, digits <span class='op'>=</span> <span class='fu'><a href='https://rdrr.io/r/base/Extremes.html'>max</a></span><span class='op'>(</span><span class='fl'>3</span>, <span class='fu'><a href='https://rdrr.io/r/base/options.html'>getOption</a></span><span class='op'>(</span><span class='st'>"digits"</span><span class='op'>)</span> <span class='op'>-</span> <span class='fl'>3</span><span class='op'>)</span>, <span class='va'>...</span><span class='op'>)</span></pre>

    <h2 class="hasAnchor" id="arguments"><a class="anchor" href="#arguments"></a>Arguments</h2>
    <table class="ref-arguments">
    <colgroup><col class="name" /><col class="desc" /></colgroup>
    <tr>
      <th>variates</th>
      <td><p>A formula or a matrix specifying variates between which correlations
are being calculated.
The formula should be one-sided of the form <code>~ A + B + C</code> for variate vectors
<code>A</code>, <code>B</code>, and <code>C</code> that are present in <code>data</code>.
In the matrix case, the matrix must have <code>n</code> rows and <code>p</code> columns (for <code>p</code> variates);
if the matrix columns aren't named, <code>cor_phylo</code> will name them <code>par_1 ... par_p</code>.</p></td>
    </tr>
    <tr>
      <th>species</th>
      <td><p>A one-sided formula implicating the variable inside <code>data</code>
representing species, or a vector directly specifying the species.
If a formula, it must be of the form <code>~ spp</code> for the <code>spp</code> object containing
the species information inside <code>data</code>.
If a vector, it must be the same length as that of the tip labels in <code>phy</code>,
and it will be coerced to a character vector like <code>phy</code>'s tip labels.</p></td>
    </tr>
    <tr>
      <th>phy</th>
      <td><p>Either a phylogeny of class <code>phylo</code> or a prepared variance-covariance
matrix.
If it is a phylogeny, we will coerce tip labels to a character vector, and
convert it to a variance-covariance matrix assuming brownian motion evolution.
We will also standardize all var-cov matrices to have determinant of one.</p></td>
    </tr>
    <tr>
      <th>covariates</th>
      <td><p>A list specifying covariate(s) for each variate.
The list can contain only two-sided formulas or matrices.
Formulas should be of the typical form: <code>y ~ x1 + x2</code> or <code>y ~ x1 * x2</code>.
If using a list of matrices, each item must be named (e.g.,
<code><a href='https://rdrr.io/r/base/list.html'>list(y = matrix(...))</a></code> specifying variate <code>y</code>'s covariates).
If the matrix columns aren't named, <code>cor_phylo</code> will name them <code>cov_1 ... cov_q</code>,
where <code>q</code> is the total number of covariates for all variates.
Having factor covariates is not supported.
Defaults to <code>NULL</code>, which indicates no covariates.</p></td>
    </tr>
    <tr>
      <th>meas_errors</th>
      <td><p>A list or matrix containing standard errors for each variate.
If a list, it must contain only two-sided formulas like those for <code>covariates</code>
(except that you can't have multiple measurement errors for a single variate).
You can additionally pass an <code>n</code>-row matrix with column names
corresponding to the associated variate names.
Defaults to <code>NULL</code>, which indicates no measurement errors.</p></td>
    </tr>
    <tr>
      <th>data</th>
      <td><p>An optional data frame, list, or environment that contains the
variables in the model. By default, variables are taken from the environment
from which <code>cor_phylo</code> was called.</p></td>
    </tr>
    <tr>
      <th>REML</th>
      <td><p>Whether REML (versus ML) should be used for model fitting.
Defaults to <code>TRUE</code>.</p></td>
    </tr>
    <tr>
      <th>method</th>
      <td><p>Method of optimization using <code>nlopt</code> or <code><a href='https://rdrr.io/r/stats/optim.html'>optim</a></code>.
Options include <code>"nelder-mead-nlopt"</code>, <code>"bobyqa"</code>, <code>"subplex"</code>, <code>"nelder-mead-r"</code>,
and <code>"sann"</code>.
The first three are carried out by <code>nlopt</code>, and the latter two by
<code><a href='https://rdrr.io/r/stats/optim.html'>optim</a></code>.
See <a href='https://nlopt.readthedocs.io/en/latest/NLopt_Algorithms/'>https://nlopt.readthedocs.io/en/latest/NLopt_Algorithms/</a> for information
on the <code>nlopt</code> algorithms.
Defaults to <code>"nelder-mead-r"</code>.</p></td>
    </tr>
    <tr>
      <th>no_corr</th>
      <td><p>A single logical for whether to make all correlations zero.
Running <code>cor_phylo</code> with <code>no_corr = TRUE</code> is useful for comparing it to the same
model run with correlations != 0.
Defaults to <code>FALSE</code>.</p></td>
    </tr>
    <tr>
      <th>constrain_d</th>
      <td><p>If <code>constrain_d</code> is <code>TRUE</code>, the estimates of <code>d</code> are
constrained to be between zero and 1. This can make estimation more stable and
can be tried if convergence is problematic. This does not necessarily lead to
loss of generality of the results, because before using <code>cor_phylo</code>,
branch lengths of <code>phy</code> can be transformed so that the "starter" tree
has strong phylogenetic signal.
Defaults to <code>FALSE</code>.</p></td>
    </tr>
    <tr>
      <th>lower_d</th>
      <td><p>Lower bound on the phylogenetic signal parameter.
Defaults to <code>1e-7</code>.</p></td>
    </tr>
    <tr>
      <th>rel_tol</th>
      <td><p>A control parameter dictating the relative tolerance for convergence
in the optimization. Defaults to <code>1e-6</code>.</p></td>
    </tr>
    <tr>
      <th>max_iter</th>
      <td><p>A control parameter dictating the maximum number of iterations
in the optimization. Defaults to <code>1000</code>.</p></td>
    </tr>
    <tr>
      <th>sann_options</th>
      <td><p>A named list containing the control parameters for SANN
minimization.
This is only relevant if <code>method == "sann"</code>.
This list can only contain the names <code>"maxit"</code>, <code>"temp"</code>, and/or <code>"tmax"</code>,
which will control the maximum number of iterations,
starting temperature, and number of function evaluations at each temperature,
respectively.
Defaults to <code>NULL</code>, which results in <code>maxit = 1000</code>, <code>temp = 1</code>, and <code>tmax = 1</code>.
Note that these are different from the defaults for <code><a href='https://rdrr.io/r/stats/optim.html'>optim</a></code>.</p></td>
    </tr>
    <tr>
      <th>verbose</th>
      <td><p>If <code>TRUE</code>, the model <code>logLik</code> and running estimates of the
correlation coefficients and values of <code>d</code> are printed each iteration
during optimization. Defaults to <code>FALSE</code>.</p></td>
    </tr>
    <tr>
      <th>rcond_threshold</th>
      <td><p>Threshold for the reciprocal condition number of two
matrices inside the log likelihood function.
Increasing this threshold makes the optimization process more strongly
"bounce away" from badly conditioned matrices and can help with convergence
and with estimates that are nonsensical.
Defaults to <code>1e-10</code>.</p></td>
    </tr>
    <tr>
      <th>boot</th>
      <td><p>Number of parametric bootstrap replicates. Defaults to <code>0</code>.</p></td>
    </tr>
    <tr>
      <th>keep_boots</th>
      <td><p>Character specifying when to output data (indices, convergence codes,
and simulated variate data) from bootstrap replicates.
This is useful for troubleshooting when one or more bootstrap replicates
fails to converge or outputs ridiculous results.
Setting this to <code>"all"</code> keeps all <code>boot</code> parameter sets,
<code>"fail"</code> keeps parameter sets from replicates that failed to converge,
and <code>"none"</code> keeps no parameter sets.
Defaults to <code>"fail"</code>.</p></td>
    </tr>
    <tr>
      <th>mod</th>
      <td><p><code>cor_phylo</code> object that was run with the <code>boot</code> argument &gt; 0.</p></td>
    </tr>
    <tr>
      <th>refits</th>
      <td><p>One or more <code>cp_refits</code> objects containing refits of <code>cor_phylo</code>
bootstrap replicates. These are used when the original fit did not converge.
Multiple <code>cp_refits</code> objects should be input as a list.
For a given bootstrap replicate, the original fit's estimates will be used
when the fit converged.
If multiple <code>cp_refits</code> objects are input and more than one converged for a given
replicate, the estimates from the first <code>cp_refits</code> object contain a converged
fit for that replicate will be used.
Defaults to <code>NULL</code>.</p></td>
    </tr>
    <tr>
      <th>alpha</th>
      <td><p>Alpha used for the confidence intervals. Defaults to <code>0.05</code>.</p></td>
    </tr>
    <tr>
      <th>...</th>
      <td><p>arguments passed to and from other methods.</p></td>
    </tr>
    <tr>
      <th>x</th>
      <td><p>an object of class <code>cor_phylo</code>.</p></td>
    </tr>
    <tr>
      <th>digits</th>
      <td><p>the number of digits to be printed.</p></td>
    </tr>
    </table>

    <h2 class="hasAnchor" id="value"><a class="anchor" href="#value"></a>Value</h2>

    <p><code>cor_phylo</code> returns an object of class <code>cor_phylo</code>:</p>
<dt><code>call</code></dt><dd><p>The matched call.</p></dd>
<dt><code>corrs</code></dt><dd><p>The <code>p</code> x <code>p</code> matrix of correlation coefficients.</p></dd>
<dt><code>d</code></dt><dd><p>Values of <code>d</code> from the OU process for each variate.</p></dd>
<dt><code>B</code></dt><dd><p>A matrix of regression-coefficient estimates, SE, Z-scores, and P-values,
respectively. Rownames indicate which coefficient it refers to.</p></dd>
<dt><code>B_cov</code></dt><dd><p>Covariance matrix for regression coefficients.</p></dd>
<dt><code>logLik</code></dt><dd><p>The log likelihood for either the restricted likelihood
(<code>REML = TRUE</code>) or the overall likelihood (<code>REML = FALSE</code>).</p></dd>
<dt><code>AIC</code></dt><dd><p>AIC for either the restricted likelihood (<code>REML = TRUE</code>) or the
overall likelihood (<code>REML = FALSE</code>).</p></dd>
<dt><code>BIC</code></dt><dd><p>BIC for either the restricted likelihood (<code>REML = TRUE</code>) or the
overall likelihood (<code>REML = FALSE</code>).</p></dd>
<dt><code>niter</code></dt><dd><p>Number of iterations the optimizer used.</p></dd>
<dt><code>convcode</code></dt><dd><p>Conversion code for the optimizer.
This number is <code>0</code> on success and positive on failure.
<dl>
<dt>1</dt><dd><p>iteration limit reached</p></dd>
<dt>2</dt><dd><p>generic failure code (nlopt optimizers only).</p></dd>
<dt>3</dt><dd><p>invalid arguments (nlopt optimizers only).</p></dd>
<dt>4</dt><dd><p>out of memory (nlopt optimizers only).</p></dd>
<dt>5</dt><dd><p>roundoff errors limited progress (nlopt optimizers only).</p></dd>
<dt>6</dt><dd><p>user-forced termination (nlopt optimizers only).</p></dd>
<dt>10</dt><dd><p>degeneracy of the Nelder-Mead simplex (<code><a href='https://rdrr.io/r/stats/optim.html'>stats::optim</a></code> only).</p></dd></dl>
For more information on the nlopt return codes, see
<a href='https://nlopt.readthedocs.io/en/latest/NLopt_Reference/#return-values'>https://nlopt.readthedocs.io/en/latest/NLopt_Reference/#return-values</a>.</p></dd>
<dt><code>rcond_vals</code></dt><dd><p>Reciprocal condition numbers for two matrices inside
the log likelihood function. These are provided to potentially help guide
the changing of the <code>rcond_threshold</code> parameter.</p></dd>
<dt><code>bootstrap</code></dt><dd><p>A list of bootstrap output, which is simply <code><a href='https://rdrr.io/r/base/list.html'>list()</a></code> if
<code>boot = 0</code>. If <code>boot &gt; 0</code>, then the list contains fields for
estimates of correlations (<code>corrs</code>), phylogenetic signals (<code>d</code>),
coefficients (<code>B0</code>), and coefficient covariances (<code>B_cov</code>).
It also contains the following information about the bootstrap replicates:
a vector of indices relating each set of information to the bootstrapped
estimates (<code>inds</code>),
convergence codes (<code>convcodes</code>), and
matrices of the bootstrapped parameters in the order they appear in the input
argument (<code>mats</code>);
these three fields will be empty if <code>keep_boots == "none"</code>.
To view bootstrapped confidence intervals, use <code>boot_ci</code>.</p></dd>

boot_ci returns a list of confidence intervals with the following fields:







    <h2 class="hasAnchor" id="methods-by-generic-"><a class="anchor" href="#methods-by-generic-"></a>Methods (by generic)</h2>

    
<ul>
<li><p><code>boot_ci</code>: returns bootstrapped confidence intervals from a <code>cor_phylo</code> object</p></li>
<li><p><code>print</code>: prints <code>cor_phylo</code> objects</p></li>
</ul>
    <h2 class="hasAnchor" id="walkthrough"><a class="anchor" href="#walkthrough"></a>Walkthrough</h2>

    

<p>For the case of two variables, the function estimates parameters for the model of
the form, for example,</p>
<p>$$X[1] =  B[1,0] + B[1,1] * u[1,1] + \epsilon[1]$$
$$X[2] =  B[2,0] + B[2,1] * u[2,1] + \epsilon[2]$$
$$\epsilon ~ Gaussian(0, V) $$</p>
<p>where \(B[1,0]\), \(B[1,1]\), \(B[2,0]\), and \(B[2,1]\) are regression
coefficients, and \(V\) is a variance-covariance matrix containing the correlation
coefficient r, parameters of the OU process \(d1\) and \(d2\), and diagonal
matrices \(M1\) and \(M2\) of measurement standard errors for \(X[1]\) and
\(X[2]\). The matrix \(V\) is \(2n x 2n\), with \(n x n\) blocks given by</p>
<p>$$V[1,1] = C[1,1](d1) + M1$$
$$V[1,2] = C[1,2](d1,d2)$$
$$V[2,1] = C[2,1](d1,d2)$$
$$V[2,2] = C[2,2](d2) + M2$$</p>
<p>where \(C[i,j](d1,d2)\) are derived from <code>phy</code> under the assumption of joint
OU evolutionary processes for each variate (see Zheng et al. 2009). This formulation
extends in the obvious way to more than two variates.</p>
    <h2 class="hasAnchor" id="references"><a class="anchor" href="#references"></a>References</h2>

    <p>Zheng, L., A. R. Ives, T. Garland, B. R. Larget, Y. Yu, and K. F. Cao.
2009. New multivariate tests for phylogenetic signal and trait correlations
applied to ecophysiological phenotypes of nine <em>Manglietia</em> species.
<em>Functional Ecology</em> <b>23</b>:1059--1069.</p>
    <h2 class="hasAnchor" id="author"><a class="anchor" href="#author"></a>Author</h2>

    <p>Anthony R. Ives, Lucas A. Nell</p>

    <h2 class="hasAnchor" id="examples"><a class="anchor" href="#examples"></a>Examples</h2>
    <pre class="examples"><div class='input'>
<span class='co'># \donttest{</span>
<span class='co'># </span>
<span class='co'># ## Simple example using data without correlations or phylogenetic</span>
<span class='co'># ## signal. This illustrates the structure of the input data.</span>
<span class='co'># </span>
<span class='co'># set.seed(10)</span>
<span class='co'># phy &lt;- ape::rcoal(10, tip.label = 1:10)</span>
<span class='co'># data_df &lt;- data.frame(</span>
<span class='co'>#     species = phy$tip.label,</span>
<span class='co'>#     # variates:</span>
<span class='co'>#     par1 = rnorm(10),</span>
<span class='co'>#     par2 = rnorm(10),</span>
<span class='co'>#     par3 = rnorm(10),</span>
<span class='co'>#     # covariate for par2:</span>
<span class='co'>#     cov2 = rnorm(10, mean = 10, sd = 4),</span>
<span class='co'>#     # measurement error for par1 and par2, respectively:</span>
<span class='co'>#     se1 = 0.2,</span>
<span class='co'>#     se2 = 0.4</span>
<span class='co'># )</span>
<span class='co'># data_df$par2 &lt;- data_df$par2 + 0.5 * data_df$cov2</span>
<span class='co'># </span>
<span class='co'># </span>
<span class='co'># # cor_phylo(variates = ~ par1 + par2 + par3,</span>
<span class='co'># #           covariates = list(par2 ~ cov2),</span>
<span class='co'># #           meas_errors = list(par1 ~ se1, par2 ~ se2),</span>
<span class='co'># #           species = ~ species,</span>
<span class='co'># #           phy = phy,</span>
<span class='co'># #           data = data_df)</span>
<span class='co'># </span>
<span class='co'># # If you've already created matrices/lists...</span>
<span class='co'># X &lt;- as.matrix(data_df[,c("par1", "par2", "par3")])</span>
<span class='co'># U &lt;- list(par2 = cbind(cov2 = data_df$cov2))</span>
<span class='co'># M &lt;- cbind(par1 = data_df$se1, par2 = data_df$se2)</span>
<span class='co'># </span>
<span class='co'># # ... you can also use those directly</span>
<span class='co'># # (notice that I'm inputting an object for `species`</span>
<span class='co'># # bc I ommitted `data`):</span>
<span class='co'># # cor_phylo(variates = X, species = data_df$species,</span>
<span class='co'># #           phy = phy, covariates = U,</span>
<span class='co'># #           meas_errors = M)</span>
<span class='co'># </span>
<span class='co'># </span>
<span class='co'># </span>
<span class='co'># </span>
<span class='co'># ## Simulation example for the correlation between two variables. The example</span>
<span class='co'># ## compares the estimates of the correlation coefficients from cor_phylo when</span>
<span class='co'># ## measurement error is incorporated into the analyses with three other cases:</span>
<span class='co'># ## (i) when measurement error is excluded, (ii) when phylogenetic signal is</span>
<span class='co'># ## ignored (assuming a "star" phylogeny), and (iii) neither measurement error</span>
<span class='co'># ## nor phylogenetic signal are included.</span>
<span class='co'># </span>
<span class='co'># # In the simulations, variable 2 is associated with a single independent variable.</span>
<span class='co'># </span>
<span class='co'># library(ape)</span>
<span class='co'># </span>
<span class='co'># set.seed(1)</span>
<span class='co'># # Set up parameter values for simulating data</span>
<span class='co'># n &lt;- 50</span>
<span class='co'># phy &lt;- rcoal(n, tip.label = 1:n)</span>
<span class='co'># trt_names &lt;- paste0("par", 1:2)</span>
<span class='co'># </span>
<span class='co'># R &lt;- matrix(c(1, 0.7, 0.7, 1), nrow = 2, ncol = 2)</span>
<span class='co'># d &lt;- c(0.3, 0.95)</span>
<span class='co'># B2 &lt;- 1</span>
<span class='co'># </span>
<span class='co'># Se &lt;- c(0.2, 1)</span>
<span class='co'># M &lt;- matrix(Se, nrow = n, ncol = 2, byrow = TRUE)</span>
<span class='co'># colnames(M) &lt;- trt_names</span>
<span class='co'># </span>
<span class='co'># # Set up needed matrices for the simulations</span>
<span class='co'># p &lt;- length(d)</span>
<span class='co'># </span>
<span class='co'># star &lt;- stree(n)</span>
<span class='co'># star$edge.length &lt;- array(1, dim = c(n, 1))</span>
<span class='co'># star$tip.label &lt;- phy$tip.label</span>
<span class='co'># </span>
<span class='co'># Vphy &lt;- vcv(phy)</span>
<span class='co'># Vphy &lt;- Vphy/max(Vphy)</span>
<span class='co'># Vphy &lt;- Vphy/exp(determinant(Vphy)$modulus[1]/n)</span>
<span class='co'># </span>
<span class='co'># tau &lt;- matrix(1, nrow = n, ncol = 1) %*% diag(Vphy) - Vphy</span>
<span class='co'># C &lt;- matrix(0, nrow = p * n, ncol = p * n)</span>
<span class='co'># for (i in 1:p) for (j in 1:p) {</span>
<span class='co'>#   Cd &lt;- (d[i]^tau * (d[j]^t(tau)) * (1 - (d[i] * d[j])^Vphy))/(1 - d[i] * d[j])</span>
<span class='co'>#   C[(n * (i - 1) + 1):(i * n), (n * (j - 1) + 1):(j * n)] &lt;- R[i, j] * Cd</span>
<span class='co'># }</span>
<span class='co'># MM &lt;- matrix(M^2, ncol = 1)</span>
<span class='co'># V &lt;- C + diag(as.numeric(MM))</span>
<span class='co'># </span>
<span class='co'># # Perform a Cholesky decomposition of Vphy. This is used to generate phylogenetic</span>
<span class='co'># # signal: a vector of independent normal random variables, when multiplied by the</span>
<span class='co'># # transpose of the Cholesky deposition of Vphy will have covariance matrix</span>
<span class='co'># # equal to Vphy.</span>
<span class='co'># iD &lt;- t(chol(V))</span>
<span class='co'># </span>
<span class='co'># # Perform Nrep simulations and collect the results</span>
<span class='co'># Nrep &lt;- 100</span>
<span class='co'># cor.list &lt;- matrix(0, nrow = Nrep, ncol = 1)</span>
<span class='co'># cor.noM.list &lt;- matrix(0, nrow = Nrep, ncol = 1)</span>
<span class='co'># cor.noP.list &lt;- matrix(0, nrow = Nrep, ncol = 1)</span>
<span class='co'># cor.noMP.list &lt;- matrix(0, nrow = Nrep, ncol = 1)</span>
<span class='co'># d.list &lt;- matrix(0, nrow = Nrep, ncol = 2)</span>
<span class='co'># d.noM.list &lt;- matrix(0, nrow = Nrep, ncol = 2)</span>
<span class='co'># B.list &lt;- matrix(0, nrow = Nrep, ncol = 3)</span>
<span class='co'># B.noM.list &lt;- matrix(0, nrow = Nrep, ncol = 3)</span>
<span class='co'># B.noP.list &lt;- matrix(0, nrow = Nrep, ncol = 3)</span>
<span class='co'># </span>
<span class='co'># </span>
<span class='co'># set.seed(2)</span>
<span class='co'># for (rep in 1:Nrep) {</span>
<span class='co'># </span>
<span class='co'>#   XX &lt;- iD %*% rnorm(2 * n)</span>
<span class='co'>#   X &lt;- matrix(XX, n, p)</span>
<span class='co'>#   colnames(X) &lt;- trt_names</span>
<span class='co'># </span>
<span class='co'>#   U &lt;- list(cbind(rnorm(n, mean = 2, sd = 10)))</span>
<span class='co'>#   names(U) &lt;- trt_names[2]</span>
<span class='co'># </span>
<span class='co'>#   X[,2] &lt;- X[,2] + B2[1] * U[[1]][,1] - B2[1] * mean(U[[1]][,1])</span>
<span class='co'># </span>
<span class='co'>#   # Call cor_phylo with (i) phylogeny and measurement error,</span>
<span class='co'>#   # (ii) just phylogeny,</span>
<span class='co'>#   # and (iii) just measurement error</span>
<span class='co'>#   z &lt;- cor_phylo(variates = X,</span>
<span class='co'>#                  covariates = U,</span>
<span class='co'>#                  meas_errors = M,</span>
<span class='co'>#                  phy = phy,</span>
<span class='co'>#                  species = phy$tip.label)</span>
<span class='co'>#   z.noM &lt;- cor_phylo(variates = X,</span>
<span class='co'>#                      covariates = U,</span>
<span class='co'>#                      phy = phy,</span>
<span class='co'>#                      species = phy$tip.label)</span>
<span class='co'>#   z.noP &lt;- cor_phylo(variates = X,</span>
<span class='co'>#                      covariates = U,</span>
<span class='co'>#                      meas_errors = M,</span>
<span class='co'>#                      phy = star,</span>
<span class='co'>#                      species = phy$tip.label)</span>
<span class='co'># </span>
<span class='co'>#   cor.list[rep] &lt;- z$corrs[1, 2]</span>
<span class='co'>#   cor.noM.list[rep] &lt;- z.noM$corrs[1, 2]</span>
<span class='co'>#   cor.noP.list[rep] &lt;- z.noP$corrs[1, 2]</span>
<span class='co'>#   cor.noMP.list[rep] &lt;- cor(cbind(</span>
<span class='co'>#     lm(X[,1] ~ 1)$residuals,</span>
<span class='co'>#     lm(X[,2] ~ U[[1]])$residuals))[1,2]</span>
<span class='co'># </span>
<span class='co'>#   d.list[rep, ] &lt;- z$d</span>
<span class='co'>#   d.noM.list[rep, ] &lt;- z.noM$d</span>
<span class='co'># </span>
<span class='co'>#   B.list[rep, ] &lt;- z$B[,1]</span>
<span class='co'>#   B.noM.list[rep, ] &lt;- z.noM$B[,1]</span>
<span class='co'>#   B.noP.list[rep, ] &lt;- z.noP$B[,1]</span>
<span class='co'># }</span>
<span class='co'># </span>
<span class='co'># correlation &lt;- rbind(R[1, 2], mean(cor.list), mean(cor.noM.list),</span>
<span class='co'>#                      mean(cor.noP.list), mean(cor.noMP.list))</span>
<span class='co'># rownames(correlation) &lt;- c("True", "With M and Phy", "Without M",</span>
<span class='co'>#                            "Without Phy", "Without Phy or M")</span>
<span class='co'># </span>
<span class='co'># signal.d &lt;- rbind(d, colMeans(d.list), colMeans(d.noM.list))</span>
<span class='co'># rownames(signal.d) &lt;- c("True", "With M and Phy", "Without M")</span>
<span class='co'># </span>
<span class='co'># est.B &lt;- rbind(c(0, 0, B2), colMeans(B.list),</span>
<span class='co'>#                colMeans(B.noM.list[-39,]),  # 39th rep didn't converge</span>
<span class='co'>#                colMeans(B.noP.list))</span>
<span class='co'># rownames(est.B) &lt;- c("True", "With M and Phy", "Without M", "Without Phy")</span>
<span class='co'># colnames(est.B) &lt;- rownames(z$B)</span>
<span class='co'># </span>
<span class='co'># # Example simulation output:</span>
<span class='co'># </span>
<span class='co'># correlation</span>
<span class='co'># #                       [,1]</span>
<span class='co'># # True             0.7000000</span>
<span class='co'># # With M and Phy   0.6943712</span>
<span class='co'># # Without M        0.2974162</span>
<span class='co'># # Without Phy      0.3715406</span>
<span class='co'># # Without Phy or M 0.3291473</span>
<span class='co'># </span>
<span class='co'># signal.d</span>
<span class='co'># #                     [,1]      [,2]</span>
<span class='co'># # True           0.3000000 0.9500000</span>
<span class='co'># # With M and Phy 0.3025853 0.9422067</span>
<span class='co'># # Without M      0.2304527 0.4180208</span>
<span class='co'># </span>
<span class='co'># est.B</span>
<span class='co'># #                      par1_0    par2_0 par2_cov_1</span>
<span class='co'># # True            0.000000000 0.0000000  1.0000000</span>
<span class='co'># # With M and Phy -0.008838245 0.1093819  0.9995058</span>
<span class='co'># # Without M      -0.008240453 0.1142330  0.9995625</span>
<span class='co'># # Without Phy     0.002933341 0.1096578  1.0028474</span>

<span class='co'># }</span>


</div></pre>
  </div>
  <div class="col-md-3 hidden-xs hidden-sm" id="pkgdown-sidebar">
    <nav id="toc" data-toggle="toc" class="sticky-top">
      <h2 data-toc-skip>Contents</h2>
    </nav>
  </div>
</div>


      <footer>
      <div class="copyright">
  <p>Developed by Anthony Ives, Russell Dinnage, Lucas A. Nell, Matthew Helmus, Daijiang Li.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="https://pkgdown.r-lib.org/">pkgdown</a> 1.6.1.</p>
</div>

      </footer>
   </div>

  


  </body>
</html>


