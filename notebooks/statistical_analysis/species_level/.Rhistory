View(reads_max_cell)
packages.install("aricode")
package.install("aricode")
install.packages("aricode")
install.packages("Rtsne")
install.package("data.table")
install.packages("data.table")
install.packages("comprehenr")
source("G:\My Drive\PhD\PlantPollinatorNetworks\plant_pollinator_networks\code\feature_computation\utils.R")
source("G:/My Drive/PhD/PlantPollinatorNetworks/plant_pollinator_networks/code/feature_computation/utils.R")
path = "C:/Users/ItayMNB10/Desktop/1.csv"
net = process_network(path)
View(net)
colnames(net)
"...1" %in% colnames(net)
install.packages(c("ade4", "ape", "BiocManager", "broom", "cachem", "classInt", "colorspace", "curl", "dbplyr", "dplyr", "dtplyr", "e1071", "fastmap", "fontawesome", "forcats", "fs", "future", "gargle", "geometry", "ggplot2", "ggpubr", "ggrepel", "ggsci", "gh", "haven", "httpuv", "httr", "igraph", "ipred", "kernlab", "knitr", "lava", "lpSolve", "lubridate", "magick", "markdown", "Matrix", "naniar", "network", "openssl", "parallelly", "pbkrtest", "phangorn", "phytools", "purrr", "raster", "RcppArmadillo", "RcppParallel", "readr", "readxl", "recipes", "rgdal", "rmarkdown", "rstatix", "sass", "sna", "sourcetools", "statnet.common", "stringi", "terra", "tibble", "tidyr", "tidyverse", "timechange", "tinytex", "TMB", "utf8", "visdat", "vroom", "xfun", "yaml"))
install.packages(c("ade4", "ape", "BiocManager", "broom", "cachem", "classInt", "colorspace", "curl", "dbplyr", "dplyr", "dtplyr", "e1071", "fastmap", "fontawesome", "forcats", "fs", "future", "gargle", "geometry", "ggplot2", "ggpubr", "ggrepel", "ggsci", "gh", "haven", "httpuv", "httr", "igraph", "ipred", "kernlab", "knitr", "lava", "lpSolve", "lubridate", "magick", "markdown", "Matrix", "naniar", "network", "openssl", "parallelly", "pbkrtest", "phangorn", "phytools", "purrr", "raster", "RcppArmadillo", "RcppParallel", "readr", "readxl", "recipes", "rgdal", "rmarkdown", "rstatix", "sass", "sna", "sourcetools", "statnet.common", "stringi", "terra", "tibble", "tidyr", "tidyverse", "timechange", "tinytex", "TMB", "utf8", "visdat", "vroom", "xfun", "yaml"))
install.packages(c("ade4", "ape", "BiocManager", "broom", "cachem", "classInt", "colorspace", "curl", "dbplyr", "dplyr", "dtplyr", "e1071", "fastmap", "fontawesome", "forcats", "fs", "future", "gargle", "geometry", "ggplot2", "ggpubr", "ggrepel", "ggsci", "gh", "haven", "httpuv", "httr", "igraph", "ipred", "kernlab", "knitr", "lava", "lpSolve", "lubridate", "magick", "markdown", "Matrix", "naniar", "network", "openssl", "parallelly", "pbkrtest", "phangorn", "phytools", "purrr", "raster", "RcppArmadillo", "RcppParallel", "readr", "readxl", "recipes", "rgdal", "rmarkdown", "rstatix", "sass", "sna", "sourcetools", "statnet.common", "stringi", "terra", "tibble", "tidyr", "tidyverse", "timechange", "tinytex", "TMB", "utf8", "visdat", "vroom", "xfun", "yaml"))
install.packages(c("ade4", "ape", "BiocManager", "broom", "cachem", "classInt", "colorspace", "curl", "dbplyr", "dplyr", "dtplyr", "e1071", "fastmap", "fontawesome", "forcats", "fs", "future", "gargle", "geometry", "ggplot2", "ggpubr", "ggrepel", "ggsci", "gh", "haven", "httpuv", "httr", "igraph", "ipred", "kernlab", "knitr", "lava", "lpSolve", "lubridate", "magick", "markdown", "Matrix", "naniar", "network", "openssl", "parallelly", "pbkrtest", "phangorn", "phytools", "purrr", "raster", "RcppArmadillo", "RcppParallel", "readr", "readxl", "recipes", "rgdal", "rmarkdown", "rstatix", "sass", "sna", "sourcetools", "statnet.common", "stringi", "terra", "tibble", "tidyr", "tidyverse", "timechange", "tinytex", "TMB", "utf8", "visdat", "vroom", "xfun", "yaml"))
install.packages(c("ade4", "ape", "BiocManager", "broom", "cachem", "classInt", "colorspace", "curl", "dbplyr", "dplyr", "dtplyr", "e1071", "fastmap", "fontawesome", "forcats", "fs", "future", "gargle", "geometry", "ggplot2", "ggpubr", "ggrepel", "ggsci", "gh", "haven", "httpuv", "httr", "igraph", "ipred", "kernlab", "knitr", "lava", "lpSolve", "lubridate", "magick", "markdown", "Matrix", "naniar", "network", "openssl", "parallelly", "pbkrtest", "phangorn", "phytools", "purrr", "raster", "RcppArmadillo", "RcppParallel", "readr", "readxl", "recipes", "rgdal", "rmarkdown", "rstatix", "sass", "sna", "sourcetools", "statnet.common", "stringi", "terra", "tibble", "tidyr", "tidyverse", "timechange", "tinytex", "TMB", "utf8", "visdat", "vroom", "xfun", "yaml"))
library(ape)
library(tidyverse)
library(glue)
library(phytools)
library(motmot)
library(caper)
library(lme4)
library(lmerTest)
library(glmmTMB) #remotes::install_github("wzmli/phyloglmm/pkg@refactor") # update this new fix: https://stackoverflow.com/questions/74961530/glmmtmb-phylo-error-in-matrixrankmatrixtmbstrucdata-tmbwhichx-length
library(phyloglmm)
library(LaplacesDemon) # documentation: https://rdrr.io/cran/phyr/man/pglmm.html
is_polyploid <- data %>% arrange(is_polyploid) %>% pull(is_polyploid, sample_id)
# need to use beta distribution for all variables distributed between 0 and 1
# https://stats.stackexchange.com/questions/508023/which-link-function-could-be-used-for-a-glm-where-the-response-is-per-cent-0
# https://rpubs.com/nicoleknight/936037
phylo_lmm_fit_degree <- phylo_glmmTMB(formula=standardized_normalised.degree~is_polyploid+(1|sample_id) +(1|network_id)+(1|num_network_plants)+(1|num_network_pollinators)
, family=ordbeta(link = "logit")
, ziformula=~1
, data=data
, phylonm = "sample_id"
, phylo = tree
, control= glmmTMBControl(rank_check = "skip"), #lmerControl(check.nobs.vs.nlev="ignore",check.nobs.vs.nRE="ignore")
)
# process data
do_weighted = FALSE
weighted_str = "unweighted"
if (do_weighted)
{
weighted_str = "weighted"
}
features_of_interest = c("d", "partner.diversity", "normalised.degree", "weighted.betweenness", "weighted.closeness")
data_path <- glue("../../../data/statistical_analysis/species_level/processed_features_with_ploidy_classification_on_{weighted_str}_networks.csv")
tree_path <- glue("../../../data/statistical_analysis/species_level/species_tree_on_{weighted_str}_networks.nwk")
unrooted_tree <- read.tree(tree_path)
tree <- multi2di(unrooted_tree)
tree <- makeNodeLabel(tree, method = "number", prefix = "Node")
data <- read.csv(data_path)
data$sample_id <- factor(data$sample_id)
data[["sample_id_numeric"]] <- as.numeric(data$sample_id)
rownames(data) <- data$sample_id
#data[["sample_id_numeric"]] <- as.numeric(data$sample_id)
#tree$tip.label = # turn into numeric?
# need to use beta distribution for all variables distributed between 0 and 1
# https://stats.stackexchange.com/questions/508023/which-link-function-could-be-used-for-a-glm-where-the-response-is-per-cent-0
# https://rpubs.com/nicoleknight/936037
phylo_lmm_fit_degree <- phylo_glmmTMB(formula=standardized_normalised.degree~is_polyploid+(1|sample_id) +(1|network_id)+(1|num_network_plants)+(1|num_network_pollinators)
, family=ordbeta(link = "logit")
, ziformula=~1
, data=data
, phylonm = "sample_id"
, phylo = tree
, control= glmmTMBControl(rank_check = "skip"), #lmerControl(check.nobs.vs.nlev="ignore",check.nobs.vs.nRE="ignore")
)
# need to use beta distribution for all variables distributed between 0 and 1
# https://stats.stackexchange.com/questions/508023/which-link-function-could-be-used-for-a-glm-where-the-response-is-per-cent-0
# https://rpubs.com/nicoleknight/936037
phylo_lmm_fit_degree <- phylo_glmmTMB(formula=standardized_normalised.degree~is_polyploid+(1|sample_id) +(1|network_id)+(1|num_network_plants)+(1|num_network_pollinators)
, family=beta_family(link = "logit")
, ziformula=~1
, data=data
, phylonm = "sample_id"
, phylo = tree
, control= glmmTMBControl(rank_check = "skip"), #lmerControl(check.nobs.vs.nlev="ignore",check.nobs.vs.nRE="ignore")
)
# need to use beta distribution for all variables distributed between 0 and 1
# https://stats.stackexchange.com/questions/508023/which-link-function-could-be-used-for-a-glm-where-the-response-is-per-cent-0
# https://rpubs.com/nicoleknight/936037
phylo_lmm_fit_degree <- phylo_glmmTMB(formula=standardized_normalised.degree~is_polyploid+(1|sample_id) +(1|network_id)+(1|num_network_plants)+(1|num_network_pollinators)
, family=ordbeta(link = "logit")
, ziformula=~1
, data=data
, phylonm = "sample_id"
, phylo = tree
, control= glmmTMBControl(rank_check = "skip"), #lmerControl(check.nobs.vs.nlev="ignore",check.nobs.vs.nRE="ignore")
)
?glmmTMB::reinstalling
install.packages("glmmTMB", type="source")
library(ape)
library(tidyverse)
library(glue)
library(phytools)
library(motmot)
library(caper)
library(lme4)
library(lmerTest)
library(glmmTMB) #remotes::install_github("wzmli/phyloglmm/pkg@refactor") # update this new fix: https://stackoverflow.com/questions/74961530/glmmtmb-phylo-error-in-matrixrankmatrixtmbstrucdata-tmbwhichx-length
library(phyloglmm)
library(LaplacesDemon) # documentation: https://rdrr.io/cran/phyr/man/pglmm.html
# process data
do_weighted = FALSE
weighted_str = "unweighted"
if (do_weighted)
{
weighted_str = "weighted"
}
features_of_interest = c("d", "partner.diversity", "normalised.degree", "weighted.betweenness", "weighted.closeness")
data_path <- glue("../../../data/statistical_analysis/species_level/processed_features_with_ploidy_classification_on_{weighted_str}_networks.csv")
tree_path <- glue("../../../data/statistical_analysis/species_level/species_tree_on_{weighted_str}_networks.nwk")
unrooted_tree <- read.tree(tree_path)
tree <- multi2di(unrooted_tree)
tree <- makeNodeLabel(tree, method = "number", prefix = "Node")
data <- read.csv(data_path)
data$sample_id <- factor(data$sample_id)
data[["sample_id_numeric"]] <- as.numeric(data$sample_id)
rownames(data) <- data$sample_id
#data[["sample_id_numeric"]] <- as.numeric(data$sample_id)
#tree$tip.label = # turn into numeric?
is_polyploid <- data %>% arrange(is_polyploid) %>% pull(is_polyploid, sample_id)
is_polyploid <- as.matrix(is_polyploid[order(match(is_polyploid, tree$tip.label))])
hist(data$standardized_normalised.degree)
# need to use beta distribution for all variables distributed between 0 and 1
# https://stats.stackexchange.com/questions/508023/which-link-function-could-be-used-for-a-glm-where-the-response-is-per-cent-0
# https://rpubs.com/nicoleknight/936037
phylo_lmm_fit_degree <- phylo_glmmTMB(formula=standardized_normalised.degree~is_polyploid+(1|sample_id) +(1|network_id)+(1|num_network_plants)+(1|num_network_pollinators)
, family=ordbeta(link = "logit")
, ziformula=~1
, data=data
, phylonm = "sample_id"
, phylo = tree
, control= glmmTMBControl(rank_check = "skip"), #lmerControl(check.nobs.vs.nlev="ignore",check.nobs.vs.nRE="ignore")
)
glmmTMB(formula=standardized_normalised.degree~is_polyploid+(1|sample_id) +(1|network_id)+(1|num_network_plants)+(1|num_network_pollinators)
, family=ordbeta(link = "logit")
, ziformula=~1
, data=data
, control= glmmTMBControl(rank_check = "skip"))
glmmTMB(formula=standardized_normalised.degree~is_polyploid+(1|sample_id) +(1|network_id)+(1|num_network_plants)+(1|num_network_pollinators)
, family=beta_family(link = "logit")
, ziformula=~1
, data=data
, control= glmmTMBControl(rank_check = "skip"))
glmmTMB(formula=standardized_normalised.degree~is_polyploid+(1|sample_id) +(1|network_id)+(1|num_network_plants)+(1|num_network_pollinators)
, family=ordbeta(link = "logit")
, ziformula=~1
, data=data
, control= glmmTMBControl(rank_check = "skip"))
glmmTMB(formula=standardized_normalised.degree~is_polyploid+(1|sample_id) +(1|network_id)+(1|num_network_plants)+(1|num_network_pollinators)
, family=ordbeta(link = "logit")
, ziformula=~1
, data=data
, control= glmmTMBControl(profile = T))
theta_pos <- 1
theta_value <- 1e3
glmmTMB(formula=standardized_normalised.degree~is_polyploid+(1|sample_id) +(1|network_id)+(1|num_network_plants)+(1|num_network_pollinators)
, family=ordbeta(link = "logit")
, ziformula=~1
, data=data
, control= glmmTMBControl(rank_check = "skip"),)
glmmTMB(formula=standardized_normalised.degree~is_polyploid+(1|sample_id) +(1|network_id)+(1|num_network_plants)+(1|num_network_pollinators)
, family=ordbeta(link = "logit")
, ziformula=~1
, data=data
, control= glmmTMBControl(rank_check = "skip"), start = list(theta = log(theta_value)), map = list(theta = factor(NA))))
glmmTMB(formula=standardized_normalised.degree~is_polyploid+(1|sample_id) +(1|network_id)+(1|num_network_plants)+(1|num_network_pollinators)
, family=ordbeta(link = "logit")
, ziformula=~1
, data=data
, control= glmmTMBControl(rank_check = "skip"), start = list(theta = log(theta_value)), map = list(theta = factor(NA))))
glmmTMB(formula=standardized_normalised.degree~is_polyploid+(1|sample_id) +(1|network_id)+(1|num_network_plants)+(1|num_network_pollinators)
, family=ordbeta(link = "logit")
, ziformula=~1
, data=data
, control= glmmTMBControl(rank_check = "skip"), start = list(theta = log(theta_value)), map = list(theta = factor(NA)))
# need to use beta distribution for all variables distributed between 0 and 1
# https://stats.stackexchange.com/questions/508023/which-link-function-could-be-used-for-a-glm-where-the-response-is-per-cent-0
# https://rpubs.com/nicoleknight/936037
phylo_lmm_fit_degree <- phylo_glmmTMB(formula=standardized_normalised.degree~is_polyploid+(1|sample_id) +(1|network_id)+(1|num_network_plants)+(1|num_network_pollinators)
, family=ordbeta(link = "logit")
, ziformula=~1
, data=data
, phylonm = "sample_id"
, phylo = tree
, control= glmmTMBControl(rank_check = "skip"), #lmerControl(check.nobs.vs.nlev="ignore",check.nobs.vs.nRE="ignore")
)
summary(phylo_lmm_fit_degree)
glmmTMB(formula=standardized_normalised.degree~is_polyploid+(1|sample_id) +(1|network_id)+(1|num_network_plants)+(1|num_network_pollinators)
, family=ordbeta(link = "logit")
, ziformula=~1
, data=data
, control= glmmTMBControl(rank_check = "skip"))
glmmTMB(formula=standardized_normalised.degree~is_polyploid+(1|network_id)+(1|num_network_plants)+(1|num_network_pollinators)
, family=ordbeta(link = "logit")
, ziformula=~1
, data=data
, control= glmmTMBControl(rank_check = "skip"))
glmmTMB(formula=standardized_normalised.degree~is_polyploid+(1|sample_id) +(1|network_id)+(1|num_network_plants)+(1|num_network_pollinators)
, family=ordbeta(link = "logit")
, data=data
, control= glmmTMBControl(rank_check = "skip"))
library(ape)
library(tidyverse)
library(glue)
library(phytools)
#library(motmot)
library(caper)
library(lme4)
library(lmerTest)
library(glmmTMB) #remotes::install_github("wzmli/phyloglmm/pkg@refactor") # update this new fix: https://stackoverflow.com/questions/74961530/glmmtmb-phylo-error-in-matrixrankmatrixtmbstrucdata-tmbwhichx-length
library(phyloglmm)
library(LaplacesDemon) # documentation: https://rdrr.io/cran/phyr/man/pglmm.html
# process data
do_weighted = FALSE
weighted_str = "unweighted"
if (do_weighted)
{
weighted_str = "weighted"
}
features_of_interest = c("d", "partner.diversity", "normalised.degree", "weighted.betweenness", "weighted.closeness")
data_path <- glue("../../../data/statistical_analysis/species_level/processed_features_with_ploidy_classification_on_{weighted_str}_networks.csv")
tree_path <- glue("../../../data/statistical_analysis/species_level/species_tree_on_{weighted_str}_networks.nwk")
unrooted_tree <- read.tree(tree_path)
tree <- multi2di(unrooted_tree)
tree <- makeNodeLabel(tree, method = "number", prefix = "Node")
data <- read.csv(data_path)
data$sample_id <- factor(data$sample_id)
data[["sample_id_numeric"]] <- as.numeric(data$sample_id)
rownames(data) <- data$sample_id
#data[["sample_id_numeric"]] <- as.numeric(data$sample_id)
#tree$tip.label = # turn into numeric?
is_polyploid <- data %>% arrange(is_polyploid) %>% pull(is_polyploid, sample_id)
is_polyploid <- as.matrix(is_polyploid[order(match(is_polyploid, tree$tip.label))])
hist(data$standardized_normalised.degree)
# need to use beta distribution for all variables distributed between 0 and 1
# https://stats.stackexchange.com/questions/508023/which-link-function-could-be-used-for-a-glm-where-the-response-is-per-cent-0
# https://rpubs.com/nicoleknight/936037
phylo_lmm_fit_degree <- phylo_glmmTMB(formula=standardized_normalised.degree~is_polyploid+(1|sample_id) +(1|network_id)+(1|num_network_plants)+(1|num_network_pollinators)
, family=ordbeta(link = "logit")
, ziformula=~1
, data=data
, phylonm = "sample_id"
, phylo = tree
, control= glmmTMBControl(rank_check = "skip"), #lmerControl(check.nobs.vs.nlev="ignore",check.nobs.vs.nRE="ignore")
)
# need to use beta distribution for all variables distributed between 0 and 1
# https://stats.stackexchange.com/questions/508023/which-link-function-could-be-used-for-a-glm-where-the-response-is-per-cent-0
# https://rpubs.com/nicoleknight/936037
phylo_lmm_fit_degree <- phylo_glmm(formula=standardized_normalised.degree~is_polyploid+(1|sample_id) +(1|network_id)+(1|num_network_plants)+(1|num_network_pollinators)
, family=ordbeta(link = "logit")
, ziformula=~1
, data=data
, phylonm = "sample_id"
, phylo = tree
, control= glmmTMBControl(rank_check = "skip"), #lmerControl(check.nobs.vs.nlev="ignore",check.nobs.vs.nRE="ignore")
)
# need to use beta distribution for all variables distributed between 0 and 1
# https://stats.stackexchange.com/questions/508023/which-link-function-could-be-used-for-a-glm-where-the-response-is-per-cent-0
# https://rpubs.com/nicoleknight/936037
phylo_lmm_fit_degree <- phylo_glmm(formula=standardized_normalised.degree~is_polyploid+(1|sample_id) +(1|network_id)+(1|num_network_plants)+(1|num_network_pollinators)
, family=ordbeta(link = "logit")
, data=data
, phylonm = "sample_id"
, phylo = tree
, control= glmmTMBControl(rank_check = "skip"), #lmerControl(check.nobs.vs.nlev="ignore",check.nobs.vs.nRE="ignore")
)
# need to use beta distribution for all variables distributed between 0 and 1
# https://stats.stackexchange.com/questions/508023/which-link-function-could-be-used-for-a-glm-where-the-response-is-per-cent-0
# https://rpubs.com/nicoleknight/936037
phylo_lmm_fit_degree <- phylo_glmm(formula=standardized_normalised.degree~is_polyploid+(1|sample_id) +(1|network_id)+(1|num_network_plants)+(1|num_network_pollinators)
, family=ordbeta(link = "logit")
, data=data
, phylonm = "sample_id"
, phylo = tree
, control= lmerControl(check.nobs.vs.nlev="ignore",check.nobs.vs.nRE="ignore")
)
library(ggplot2)
ggplot(data, aes(x = standardized_d, fill = is_polyploid)) + geom_histogram()
View(fitTMB )
View(fitTMB)
View("
fitTMB")
View("fitTMB")
remotes::install_github("saudiwin/ordbetareg_pack",build_vignettes=TRUE,dependencies = TRUE)
library(glmmTMB)
library(ordbetareg)
install.packages("ordbetareg")
library(glmmTMB)
library(ordbetareg)
library(dplyr)
library(ape)
library(tidyverse)
library(glue)
library(phytools)
library(motmot)
library(caper)
library(lme4)
library(lmerTest)
library(glmmTMB) #remotes::install_github("wzmli/phyloglmm/pkg@refactor") # update this new fix: https://stackoverflow.com/questions/74961530/glmmtmb-phylo-error-in-matrixrankmatrixtmbstrucdata-tmbwhichx-length
library(phyloglmm)
library(LaplacesDemon) # documentation: https://rdrr.io/cran/phyr/man/pglmm.html
# process data
do_weighted = TRUE
weighted_str = "unweighted"
if (do_weighted)
{
weighted_str = "weighted"
}
features_of_interest = c("d", "partner.diversity", "normalised.degree", "weighted.betweenness", "weighted.closeness")
data_path <- glue("../../../data/statistical_analysis/species_level/processed_features_with_ploidy_classification_on_{weighted_str}_networks.csv")
tree_path <- glue("../../../data/statistical_analysis/species_level/species_tree_on_{weighted_str}_networks.nwk")
unrooted_tree <- read.tree(tree_path)
tree <- multi2di(unrooted_tree)
tree <- makeNodeLabel(tree, method = "number", prefix = "Node")
data <- read.csv(data_path)
data$sample_id <- factor(data$sample_id)
rownames(data) <- data$sample_id
data <- data %>% mutate(d = asin(sqrt(d))) # transform d to non-01 limited range (logit produced right skwed distribution)
data <- data %>% mutate(weighted.betweenness = asin(sqrt(weighted.betweenness)))
data <- data %>% mutate(normalised.degree = asin(sqrt(normalised.degree)))
library(ape)
library(tidyverse)
library(glue)
library(phytools)
library(motmot)
library(caper)
library(lme4)
library(lmerTest)
library(glmmTMB) #remotes::install_github("wzmli/phyloglmm/pkg@refactor") # update this new fix: https://stackoverflow.com/questions/74961530/glmmtmb-phylo-error-in-matrixrankmatrixtmbstrucdata-tmbwhichx-length
library(phyloglmm)
library(LaplacesDemon)
do_weighted = TRUE
weighted_str = "unweighted"
if (do_weighted)
{
weighted_str = "weighted"
}
features_of_interest = c("d", "partner.diversity", "normalised.degree", "weighted.betweenness", "weighted.closeness")
data_path <- glue("../../../data/statistical_analysis/species_level/processed_features_with_ploidy_classification_on_{weighted_str}_networks.csv")
tree_path <- glue("../../../data/statistical_analysis/species_level/species_tree_on_{weighted_str}_networks.nwk")
unrooted_tree <- read.tree(tree_path)
library(ape)
library(tidyverse)
library(glue)
library(phytools)
library(caper)
library(lme4)
library(lmerTest)
remotes::install_github("wzmli/phyloglmm/pkg@refactor") # update this new fix: https://stackoverflow.com/questions/74961530/glmmtmb-phylo-error-in-matrixrankmatrixtmbstrucdata-tmbwhichx-length
library(phyloglmm)
library(LaplacesDemon) # documentation: https://rdrr.io/cran/phyr/man/pglmm.html
library(ggplot2)
library(ggpubr)
library(rstatix)
library(DHARMa)
install.packages("DHARMa")
data$is_polyploid = factor(data$is_polyploid)
do_weighted = FALSE
weighted_str = "unweighted"
if (do_weighted)
{
weighted_str = "weighted"
}
features_of_interest = c("standardized_d", "standardized_partner.diversity", "standardized_normalised.degree", "standardized_weighted.betweenness", "standardized_weighted.closeness", "standardized_hubbiness_score")
data_path <- glue("../../../data/statistical_analysis/species_level/processed_features_with_ploidy_classification_on_{weighted_str}_networks.csv")
pair_data_path = glue("../../../data/statistical_analysis/species_level/pair_data_on_{weighted_str}_networks.csv")
tree_path <- glue("../../../data/statistical_analysis/species_level/species_tree_on_{weighted_str}_networks.nwk")
unrooted_tree <- read.tree(tree_path)
getcwd()
cwd()
getwd()
setwd("G:\My Drive\PhD\PlantPollinatorNetworks\plant_pollinator_networks\notebooks\statistical_analysis\species_level")
setwd("G:/My Drive/PhD/PlantPollinatorNetworks/plant_pollinator_networks/notebooks/statistical_analysis/species_level/")
perform_analysis.ipynb
do_weighted = FALSE
weighted_str = "unweighted"
if (do_weighted)
{
weighted_str = "weighted"
}
features_of_interest = c("standardized_d", "standardized_partner.diversity", "standardized_normalised.degree", "standardized_weighted.betweenness", "standardized_weighted.closeness", "standardized_hubbiness_score")
data_path <- glue("../../../data/statistical_analysis/species_level/processed_features_with_ploidy_classification_on_{weighted_str}_networks.csv")
pair_data_path = glue("../../../data/statistical_analysis/species_level/pair_data_on_{weighted_str}_networks.csv")
tree_path <- glue("../../../data/statistical_analysis/species_level/species_tree_on_{weighted_str}_networks.nwk")
unrooted_tree <- read.tree(tree_path)
tree <- multi2di(unrooted_tree)
tree <- makeNodeLabel(tree, method = "number", prefix = "Node")
data <- read.csv(data_path)
data$sample_id <- factor(data$sample_id)
data[["sample_id_numeric"]] <- as.numeric(data$sample_id)
rownames(data) <- data$sample_id
pair_data <- read.csv(pair_data_path)
data$is_polyploid = factor(data$is_polyploid)
ggplot(data, aes(x = standardized_hubbiness_score, fill = is_polyploid)) + geom_histogram()
glmm_fit_d <- glmmTMB(formula=standardized_hubbiness_score~is_polyploid+(1|network_id)+(1|num_network_size)
, family=ordbeta(link = "logit")
, ziformula=~1
, data=data
, control= glmmTMBControl(rank_check = "skip"),
)
glmm_fit_d <- glmmTMB(formula=standardized_hubbiness_score~is_polyploid+(1|network_id)+(1|network_size)
, family=ordbeta(link = "logit")
, ziformula=~1
, data=data
, control= glmmTMBControl(rank_check = "skip"),
)
ordbetareg(formula=standardized_hubbiness_score~is_polyploid+(1|network_id)+(1|network_size), data=data)
data
colnames(data)
data$Plant
data$Plant[1]
str_replace(data$Plant[1], "sis", "did")
library(tidyverse)
library(bipartite)
library(matrixStats)
process_network <- function(network_path)
{
if (! file.exists(network_path))
{
print(paste("network ", network_path, "does not exist"))
return (NA)
}
network <- read_csv(file = network_path, show_col_types = FALSE)
if ("Plant" %in% colnames(network))
{
network = network %>% column_to_rownames(., var = "Plant")
}
else if ("...1" %in% colnames(network))
{
network = network %>% column_to_rownames(., var="...1")
}
else
{
print("no relevant columns")
}
return(network)
}
pair_data = read.csv("C:/Users/ItayMNB10/Desktop/test.csv")
View(pair_data)
network = process_network("C:/Users/ItayMNB10/Desktop/13.csv")
network = process_network("C:/Users/ItayMNB10/Desktop/13.csv")
get_module_sharing <-function(modules_matrix, member1, member2)
{
m1_modules = modules_matrix[, which(member1 == rownames(network))+2] > 0
m2_modules = modules_matrix[, which(member2 == rownames(network))+2] > 0
frac_shared_modules = sum(m1_modules&m2_modules) / ncol(modules_matrix)
return(frac_shared_modules)
}
modules = computeModules(network)
modules_matrix = as.matrix(slot(modules, "modules"))
View(modules_matrix)
network
View(pair_data)
member1 = "Achillea millefolium"
member2 = "
Crepis capillaris"
member2 = "	Crepis capillaris"
member2 = "Crepis capillaris"
which(member1 == rownames(network)
)
which(member2 == rownames(network))
get_module_sharing <-function(network, modules_matrix, member1, member2)
{
m1_modules = modules_matrix[, which(member1 == rownames(network))+2] > 0
m2_modules = modules_matrix[, which(member2 == rownames(network))+2] > 0
frac_shared_modules = sum(m1_modules&m2_modules) / ncol(modules_matrix)
return(frac_shared_modules)
}
pairs_data["frac_shared_modules"] = mapply(get_module_sharing,
network,
modules_matrix,
pairs_data$member1,
pairs_data$member2)
pairs_data = pair_data
pairs_data["frac_shared_modules"] = mapply(get_module_sharing,
network,
modules_matrix,
pairs_data$member1,
pairs_data$member2)
ncol(modules_matrix)
nco;(network)
ncol(network)
nrow(network)
12_27_2
12+27+2
modules_matrix[, which(member1 == rownames(network))+2
]
modules_matrix[, which(member2 == rownames(network))+2]
frac_shared_modules = sum(m1_modules&m2_modules) / ncol(modules_matrix)
m1_modules = modules_matrix[, which(member1 == rownames(network))+2] > 0
m2_modules = modules_matrix[, which(member2 == rownames(network))+2] > 0
frac_shared_modules = sum(m1_modules&m2_modules) / ncol(modules_matrix)
get_module_sharing <-function(member1, member2)
{
m1_modules = modules_matrix[, which(member1 == rownames(network))+2] > 0
m2_modules = modules_matrix[, which(member2 == rownames(network))+2] > 0
frac_shared_modules = sum(m1_modules&m2_modules) / ncol(modules_matrix)
return(frac_shared_modules)
}
pairs_data["frac_shared_modules"] = mapply(get_module_sharing,
pairs_data$member1,
pairs_data$member2)
pairs_data
View(pairs_data)
